######################################################################################################################
# Copyright (C) 2017-2020 Spine project consortium
# This file is part of Spine Items.
# Spine Items is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General
# Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option)
# any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General
# Public License for more details. You should have received a copy of the GNU Lesser General Public License along with
# this program. If not, see <http://www.gnu.org/licenses/>.
######################################################################################################################

"""
Contains NotebookInstance class.

:authors: P. Savolainen (VTT), E. Rinne (VTT), R. Brady (UCD)
:date:   05.02.2021
"""
import os
from spine_engine.execution_managers import KernelExecutionManager


class NotebookInstance:
    """Notebook instance base class."""

    def __init__(self, notebook_specification, basedir, settings, logger, owner):
        """

        Args:
            notebook_specification (NotebookSpecification): the notebook specification for this instance
            basedir (str): the path to the directory where this instance should run
            settings (QSettings): Toolbox settings
            logger (LoggerInterface): a logger instance
            owner (ExecutableItemBase): The item that owns the instance
        """
        self.notebook_specification = notebook_specification
        self.kernel_name = None
        self.basedir = basedir
        self._settings = settings
        self._logger = logger
        self._owner = owner
        self._input_vars = self.notebook_specification.input_vars
        self._output_vars = self.notebook_specification.output_vars
        self._nb_path = None
        self._nb_out_path = None
        self._nb_parameters = {}
        self.args = list()  # List of command line arguments for the program
        self.exec_mngr = None

    @property
    def owner(self):
        return self._owner

    def is_running(self):
        return self.exec_mngr is not None

    def terminate_instance(self):
        """Terminates Notebook instance execution."""
        if not self.exec_mngr:
            return
        self.exec_mngr.stop_execution()
        self.exec_mngr = None

    def set_notebook_out_path(self):
        """
        Sets file name and path for output notebook generated by papermill
        """
        append_out = "_out"
        nb_filename_split = os.path.splitext(self.notebook_specification.includes[0])
        nb_out_filename = nb_filename_split[0] + append_out + nb_filename_split[1]
        return os.path.join(self.basedir, nb_out_filename).replace(os.sep, '/')

    def prepare(self, nb_src_dst_mapping, args):
        """See base class."""
        nb_type = self.notebook_specification.notebook_type
        if nb_src_dst_mapping:
            nb_src_name = self.notebook_specification.includes[0]
            self._nb_path = nb_src_dst_mapping[nb_src_name]
        else:
            self._nb_path = self.notebook_specification.includes[0]
        # map input vars to resources
        for i, name in enumerate(self._input_vars):
            self._nb_parameters[name] = args[i]
        # Map output vars to output file paths
        if len(self.notebook_specification.output_files) > 0:
            for i, name in enumerate(self._output_vars):
                filename = self.notebook_specification.output_files[i]
                self._nb_parameters[name] = os.path.join(self.basedir, filename)
        # set kernel
        if self.notebook_specification.kernel_name:
            self.kernel_name = self.notebook_specification.kernel_name
        else:
            self.kernel_name = self._settings.value("appSettings/pythonKernel", defaultValue="")
        # set out notebook path
        self._nb_out_path = self.set_notebook_out_path()
        # format command for kernel. papermill is dependency of kernel executing command, not toolbox or engine
        papermill_execute_command = (
            f"pm.execute_notebook("
            f"'{self._nb_path}',"
            f"'{self._nb_out_path}',"
            f"kernel_name='{self.kernel_name}',"
            f"parameters={self._nb_parameters})"
        )
        if nb_type == 'julia':
            # use julia PyCall pkg to execute python commands
            self.args.append('using PyCall')
            # format command to ignore python syntax in julia
            papermill_execute_command = f'py"""import papermill as pm\n\n{papermill_execute_command}"""'
        else:
            self.args.append('import papermill as pm')
        self.args.append(papermill_execute_command)
        self.exec_mngr = KernelExecutionManager(
            self._logger, nb_type, self.kernel_name, *self.args, group_id=self.owner.group_id
        )

    def execute(self):
        """Executes a prepared instance."""
        ret = self.exec_mngr.run_until_complete()
        if ret != 0:
            self._logger.msg_error.emit(f"\t<b>Notebook exit with</b> [exit code:{ret}]")
        self.exec_mngr = None
        return ret

